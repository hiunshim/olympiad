#!/usr/bin/env python
import os
import sys
from io import BytesIO, IOBase


def main():
    for t in range(int(input())):
        n = int(input())
        s = list(input())
        flag = False
        for i in range(6):
            for j in range(6):
                for k in range(2):
                    if n - i - j < 0 or (n - i - j) % 6 == 0:
                        continue
                    pattern = "001011"
                    cur = -k
                    flag2 = True
                    rollBack = []
                    for p in range(i, n - j):
                        if s[p] != "?" and s[p] != pattern[cur]:
                            flag2 = False
                            break
                        rollBack.append((p, s[p]))
                        s[p] = pattern[cur]
                        cur += 1 - 2 * k
                        cur %= 6
                    if not flag2:
                        for elem in rollBack:
                            s[elem[0]] = elem[1]
                        continue
                    
                    for mask in range(1 << i + j):
                        flag4 = True
                        rollBack2 = []
                        for i1 in range(i):
                            if s[i1] != "?" and ord(s[i1]) - ord("0") != bool(mask & (1 << i1)):
                                flag4 = False
                                break
                            rollBack2.append((i1, s[i1]))
                            s[i1] = chr(ord("0") + bool(mask & (1 << i1)))
                        for j1 in range(j):
                            if s[(n - j1 - 1)] != "?" and ord(s[n - j1 - 1]) - ord("0") != bool(mask & (1 << j1 + i)):
                                flag4 = False
                                break
                            rollBack2.append(((n - j1 - 1), s[(n - j1 - 1)]))
                            s[(n - j1 - 1)] = chr(ord("0") + bool(mask & (1 << (j1 + i))))

                        if not flag4:
                            for elem in rollBack2:
                                s[elem[0]] = elem[1]
                            continue

                        flag3 = True

                        for i3 in range(min(20, n - 5)):
                            if i3 + 4 >= n:
                                continue
                            if s[i3] == s[i3 + 4] and s[i3 + 1] == s[i3 + 3]:
                                flag3 = False
                            if i3 + 5 >= n:
                                continue
                            if s[i3] == s[i3 + 5] and s[i3 + 1] == s[i3 + 4] and s[i3 + 2] == s[i3 + 3]:
                                flag3 = False
                        for i3 in range(max(0, n - 20), n):
                            if i3 + 4 >= n:
                                continue
                            if s[i3] == s[i3 + 4] and s[i3 + 1] == s[i3 + 3]:
                                flag3 = False
                            if i3 + 5 >= n:
                                continue
                            if s[i3] == s[i3 + 5] and s[i3 + 1] == s[i3 + 4] and s[i3 + 2] == s[i3 + 3]:
                                flag3 = False
                        
                        flag |= flag3

                        for elem in rollBack2:
                            s[elem[0]] = elem[1]
                        
                    for elem in rollBack:
                        s[elem[0]] = elem[1]


        
        print(f'Case #{t + 1}: {"IMPOSSIBLE" if not flag else "POSSIBLE"}')






# region fastio

BUFSIZE = 8192


class FastIO(IOBase):
    newlines = 0

    def __init__(self, file):
        self._file = file
        self._fd = file.fileno()
        self.buffer = BytesIO()
        self.writable = "x" in file.mode or "r" not in file.mode
        self.write = self.buffer.write if self.writable else None

    def read(self):
        while True:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            if not b:
                break
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines = 0
        return self.buffer.read()

    def readline(self):
        while self.newlines == 0:
            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))
            self.newlines = b.count(b"\n") + (not b)
            ptr = self.buffer.tell()
            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)
        self.newlines -= 1
        return self.buffer.readline()

    def flush(self):
        if self.writable:
            os.write(self._fd, self.buffer.getvalue())
            self.buffer.truncate(0), self.buffer.seek(0)


class IOWrapper(IOBase):
    def __init__(self, file):
        self.buffer = FastIO(file)
        self.flush = self.buffer.flush
        self.writable = self.buffer.writable
        self.write = lambda s: self.buffer.write(s.encode("ascii"))
        self.read = lambda: self.buffer.read().decode("ascii")
        self.readline = lambda: self.buffer.readline().decode("ascii")


sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)
input = lambda: sys.stdin.readline().rstrip("\r\n")

# endregion

if __name__ == "__main__":
    main()